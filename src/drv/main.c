#include <ntddk.h>
#include "common.h"


#define NT_DEVICE_NAME      L"\\Device\\KernMemCtrler"
#define DOS_DEVICE_NAME     L"\\DosDevices\\KernMemCtrler"


DRIVER_UNLOAD OnUnload;
VOID OnUnload( IN PDRIVER_OBJECT DriverObject )
{	
	PDEVICE_OBJECT device = DriverObject->DeviceObject;
    UNICODE_STRING uniWin32NameString;
	
	RtlInitUnicodeString( &uniWin32NameString, DOS_DEVICE_NAME );	
	IoDeleteSymbolicLink( &uniWin32NameString );

    if ( device != NULL )
    {
        IoDeleteDevice( device );
    }
}


NTSTATUS ReadKernelMemory(IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp)
{
	NTSTATUS            NtStatus = STATUS_SUCCESS;
	PIO_STACK_LOCATION  pIrpSp;
	ULONG               BytesReturned = 0;
	PUCHAR              ioBuffer = NULL;
	ULONG               inputBufferLength;
	ULONG               outputBufferLength;
	MEMDESCRIPT			memDescript;
	unsigned char 		*buffer = 0;

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	
	ioBuffer = pIrp->AssociatedIrp.SystemBuffer;
	inputBufferLength  = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
	outputBufferLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

	if( inputBufferLength != sizeof( MEMDESCRIPT ) )
	{
		DbgPrint("ReadKernelMemory - inputBufferLength too small\n");
		NtStatus = STATUS_INVALID_PARAMETER;
		goto CompleteTheIRP;
	}
	
	RtlCopyMemory(&memDescript, ioBuffer, sizeof(memDescript));	
	if( memDescript.HEADER.address < 0x80000000 )
	{
		DbgPrint("ReadKernelMemory - address too low\n");
		NtStatus = STATUS_INVALID_PARAMETER;
		goto CompleteTheIRP;
	}
	
	if( outputBufferLength < memDescript.HEADER.length)
	{
		DbgPrint("ReadKernelMemory - outputBufferLength too small\n");
		NtStatus = STATUS_INVALID_PARAMETER;
		goto CompleteTheIRP;
	}
		
	if (MmIsAddressValid((void*)memDescript.HEADER.address))
	{
		buffer = (unsigned char*) (memDescript.HEADER.address);
		DbgPrint("Reading address: %u, length: %u\n", buffer, memDescript.HEADER.length);
		//TODO: risk of reading the next page which might be paged out if memdescript.HEADER.length crosses a page boundary
		RtlCopyMemory(ioBuffer, buffer, memDescript.HEADER.length);
		BytesReturned = memDescript.HEADER.length;
		DbgPrint("Read %u bytes\n", BytesReturned);
	}
	else
	{
		DbgPrint("ReadKernelMemory - address not read, page not valid\n");
		NtStatus = STATUS_ACCESS_DENIED;
		goto CompleteTheIRP;
	}	
	
CompleteTheIRP:

   pIrp->IoStatus.Information = BytesReturned;
   pIrp->IoStatus.Status = NtStatus;
   IoCompleteRequest(pIrp, IO_NO_INCREMENT);   
   
   return NtStatus;
}


NTSTATUS WriteKernelMemory(IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp)
{
	NTSTATUS            NtStatus = STATUS_SUCCESS;
	PIO_STACK_LOCATION  pIrpSp;
	ULONG               BytesReturned = 0;
	PUCHAR              ioBuffer = NULL;
	ULONG               inputBufferLength;
	ULONG               outputBufferLength;
	MEMDESCRIPT*		memDescript = 0;
	unsigned char* 		buffer = 0;
	unsigned int		dataLength = 0;
	unsigned int		status = 0;

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	
	ioBuffer = pIrp->AssociatedIrp.SystemBuffer;
	inputBufferLength  = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
	outputBufferLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

	if( inputBufferLength < sizeof( MEMDESCRIPT ) )
	{
		DbgPrint("WriteKernelMemory - inputBufferLength too small\n");
		NtStatus = STATUS_INVALID_PARAMETER;
		goto CompleteTheIRP;
	}
	
	memDescript = (MEMDESCRIPT*)ioBuffer;
	if( memDescript->HEADER.address < 0x80000000 )
	{
		DbgPrint("WriteKernelMemory - address too low\n");
		NtStatus = STATUS_INVALID_PARAMETER;
		goto CompleteTheIRP;
	}
		
	dataLength = inputBufferLength - (sizeof memDescript->HEADER);
	if(dataLength < memDescript->HEADER.length)
	{
		DbgPrint("WriteKernelMemory - dataLength smaller than specified\n");
		NtStatus = STATUS_INVALID_PARAMETER;
		goto CompleteTheIRP;
	}
	
	
	//disable memory write protection
	__asm
	{
		push eax
		mov  eax, CR0
		and  eax, 0FFFEFFFFh
		mov  CR0, eax
		pop  eax
	}


	if (MmIsAddressValid((void*)memDescript->HEADER.address))
	{
		buffer = (unsigned char*)&memDescript->buffer;
		DbgPrint("Writing address: %u, length: %u\n", memDescript->HEADER.address, memDescript->HEADER.length);
		//TODO: risk here if length causes the copy to cross a page boundary
		RtlCopyMemory((void*)memDescript->HEADER.address, buffer, memDescript->HEADER.length);
		
		BytesReturned = sizeof(status);
		RtlCopyMemory(ioBuffer, &status, sizeof(status));
	}
	else
	{
		DbgPrint("WriteKernelMemory - address not written, page not valid\n");
		NtStatus = STATUS_ACCESS_DENIED;		
	}
	
	
	//Enable memory write protection
	__asm
	{
		push eax
		mov  eax, CR0
		or   eax, NOT 0FFFEFFFFh
		mov  CR0, eax
		pop  eax
	}


CompleteTheIRP:

   pIrp->IoStatus.Information = BytesReturned;
   pIrp->IoStatus.Status = NtStatus;
   IoCompleteRequest(pIrp, IO_NO_INCREMENT);   
   
   return NtStatus;
}



/*void find()
{
	unsigned char *buffer;
	unsigned char *pattern;	
	int found = 0;
	int pos = 0;
	
	pattern = "\xe8\xc7\x6f\xff\xff";
	
	for( pos=0x80000000; pos<0xfffff000; pos=pos+0x1000 )
	{
		buffer = (unsigned char*) (pos+0x0ea);
		//ret = ReadKernelMemory( (void*) (pos+0x0ea), (void*) buffer, 5 );		
		if (MmIsAddressValid(buffer))
		{		
			if ( RtlCompareMemory(buffer, pattern, 5) == 5 )
			{
				
				//code_address = pos + 0x0ea;
				//printf( "Patching code at %x\n" , code_address );
				found = 1;
				break;
			}
		}		
		
	}
	
	if (found)
	{
		DbgPrint("Found\n");		
	}
	else
	{
		DbgPrint("Not found\n");
	}
}*/


NTSTATUS SearchKernelMemory(IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp)
{	
	NTSTATUS            NtStatus = STATUS_SUCCESS;
	PIO_STACK_LOCATION  pIrpSp;
	ULONG               BytesReturned = 0;
	PUCHAR              ioBuffer = NULL;
	ULONG               inputBufferLength;
	ULONG               outputBufferLength;
	MEMDESCRIPT*		memDescript;
	unsigned char* 		buffer = 0;
	unsigned int		patternLength = 0;
	unsigned int		pos = 0;
	unsigned int 		codeAddr = 0;
	int					found = FALSE;
	unsigned int		i = 0;

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	
	ioBuffer = pIrp->AssociatedIrp.SystemBuffer;
	inputBufferLength  = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
	outputBufferLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

	if( inputBufferLength < sizeof( MEMDESCRIPT ) )
	{
		DbgPrint("SearchKernelMemory - inputBufferLength too small\n");
		NtStatus = STATUS_INVALID_PARAMETER;
		goto CompleteTheIRP;
	}
	
	memDescript = (MEMDESCRIPT*)ioBuffer;
	if( memDescript->HEADER.address < 0x80000000 )
	{
		DbgPrint("SearchKernelMemory - address too low\n");
		NtStatus = STATUS_INVALID_PARAMETER;
		goto CompleteTheIRP;
	}
		
	patternLength = inputBufferLength - sizeof(memDescript->HEADER);
	if(patternLength < memDescript->HEADER.length)
	{
		DbgPrint("SearchKernelMemory - patternlength not as big as specified\n");
		NtStatus = STATUS_INVALID_PARAMETER;
		goto CompleteTheIRP;
	}
	
	if( outputBufferLength < sizeof(codeAddr) )
	{
		DbgPrint("SearchKernelMemory - outputBufferLength too small\n");
		NtStatus = STATUS_INVALID_PARAMETER;
		goto CompleteTheIRP;
	}
	
	DbgPrint("memDescript->HEADER.address = %u\n", memDescript->HEADER.address);
	DbgPrint("pattern length is: %u and pattern is:", memDescript->HEADER.length);
	for(i = 0; i < memDescript->HEADER.length; i++)
	{
		DbgPrint("%u\n", (&memDescript->buffer)[i]);	
	}
	for( pos = memDescript->HEADER.address; pos < 0xfffff000; pos = pos + 0x1000 )
	{
		buffer = (unsigned char*) (pos+0x0ea);
		if (MmIsAddressValid(buffer))
		{
			if ( RtlCompareMemory(buffer, &memDescript->buffer, memDescript->HEADER.length) == memDescript->HEADER.length )
			{
				codeAddr = pos + 0x0ea;
				found = 1;
				break;
			}
		}
	}
	
	if (found)
	{
		DbgPrint("SearchKernelMemory - Found pattern\n");
		BytesReturned = sizeof(codeAddr);
		RtlCopyMemory(ioBuffer, &codeAddr, sizeof(codeAddr));
	}
	else
	{
		DbgPrint("SearchKernelMemory - pattern not found\n");
		(*ioBuffer) = 0;
	}
	

CompleteTheIRP:

   pIrp->IoStatus.Information = BytesReturned;
   pIrp->IoStatus.Status = NtStatus;
   IoCompleteRequest(pIrp, IO_NO_INCREMENT);   
   
   return NtStatus;
}


DRIVER_DISPATCH IOControl;
NTSTATUS IOControl(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp )
{
	NTSTATUS            NtStatus = STATUS_SUCCESS;
	PIO_STACK_LOCATION  IrpSp;
	ULONG               FunctionCode;
	
	IrpSp = IoGetCurrentIrpStackLocation(pIrp);
	FunctionCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;
	
	
	switch (FunctionCode)
	{
		case IOCTL_HYPVUSERIO_READ_KERNEL_MEM:
			return( ReadKernelMemory(
                  pDeviceObject,
                  pIrp
                  )
               );			
			
		case IOCTL_HYPVUSERIO_WRITE_KERNEL_MEM:
			return( WriteKernelMemory(
                  pDeviceObject,
                  pIrp
                  )
               );
			
		case IOCTL_HYPVUSERIO_SEARCH_MEM:
			return( SearchKernelMemory(
                  pDeviceObject,
                  pIrp
                  )
               );

		default:
            NtStatus = STATUS_NOT_SUPPORTED;
            break;
	}
	
	
	if (NtStatus != STATUS_PENDING)
    {
        pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = NtStatus;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }
	
	return NtStatus;
}

DRIVER_DISPATCH defaultDispatch;
NTSTATUS defaultDispatch( IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp )
{	
    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	
    return STATUS_SUCCESS;
}


NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{	
	UNICODE_STRING deviceNameUnicodeString;	
	PDEVICE_OBJECT device;
	UNICODE_STRING ntUnicodeString;	
	UNICODE_STRING ntWin32NameString;
	NTSTATUS ntStatus;
	
	RtlInitUnicodeString( &ntUnicodeString, NT_DEVICE_NAME );
		
	ntStatus = IoCreateDevice ( 
		DriverObject, 
		0,
		&ntUnicodeString,
		FILE_DEVICE_UNKNOWN, 
		0, 
		TRUE, 
		&device );
	if( !NT_SUCCESS(ntStatus) ) 
	{
		DbgPrint("DriverEntry - IoCreateDevice failed\n");
        return ntStatus;
    }
	
	RtlInitUnicodeString( &ntWin32NameString, DOS_DEVICE_NAME );
	ntStatus = IoCreateSymbolicLink( &ntWin32NameString, &ntUnicodeString );

    if ( !NT_SUCCESS( ntStatus ) )
    {        
        DbgPrint("DriverEntry - IoCreateSymbolicLink failed\n");
        IoDeleteDevice( device );
		return ntStatus;
	}


	DriverObject->MajorFunction[IRP_MJ_CREATE] = defaultDispatch;
	DriverObject->MajorFunction[IRP_MJ_CLEANUP] = defaultDispatch;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = defaultDispatch;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = IOControl;
	DriverObject->DriverUnload  = OnUnload;

	//find();
	
	return STATUS_SUCCESS;
}